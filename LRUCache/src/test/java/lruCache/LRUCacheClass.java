//一定の数に達したら使われていない順に要素が削除されていくMapのような入れ物を作りたい
//このためLastRecentlyUsedCacheを作成する。
//キャッシュの最大サイズに達した時に、最も使われていないデータから順に消される仕組みが欲しい

/*クラスの持つべきこと
 * 2つの配列を持つ　要素数はキャッシュサイズ
 * 1つはキー値、一つはデータ
 * 
 * put関数でデータとキー値の追加
 * -既に入っているキー値と同一のキー値が指定されたらデータは上書きされる（Mapの仕様から）
 * get関数で引数に入れたキー値と一致するデータをコンソールに書き出す
 * 
 * 書き出しをされたとき、それを格納する配列とキー値を格納する配列の要素（内容）を最も最後の要素に持ってくる
 * データの追加するとき、最も最後の要素に追加する。
 * データの追加して要素がいっぱいになった時（キャッシュ最大サイズに達した時）最も最初の要素を削除し、順序を繰り上げる
 * -このクラスに格納されるデータの最大数は、常にキャッシュサイズ-1に保たれる
 */

/*=====================================
 * 消されるのは最も過去に参照したデータ。頻度ではない
 * ====================================
 */

/*TODO
 * [x] 要素数が5の配列2つを持つクラスの実装　型はstring
 * 
 * [ ] put関数でキー値とデータを要素の入っていない配列の要素に格納
 * - [x] 0番目の要素に引数を格納する
 * [ ] get関数で指定されたキー値と共に格納されたデータをコンソール上に表示
 *  - [x] 文字列1を返すget関数
 *
 * [ ] データが入っていない要素の検出関数を実装
 * - [x] 整数1を返す
 * - [x] nullの一致した1番目までの要素を検出し、0or1を返す
 * - [ ] nullの一致をしたn番目の要素を検出し、整数nを返す
 * 
 *　[ ] put→格納したキー値とデータが配列の最後の要素だった時一番初めの要素(hoge[0]の要素)を消し、すべての要素に入っているデータを[n-1]番目に移す
 *　[ ] put→配列の最も最後の要素をnullにする
 * [ ] get→呼び出された要素のデータは先頭のnullが格納された要素に移し、元あった要素よりも後の要素を[n-1]に移す
 * 
 * [ ] 配列の要素数をnに変更
 */

package lruCache;

public class LRUCacheClass {
	String key[] = new String[5];
	String data[] = new String[5];
	
	//キー値とデータを格納する関数
	public void put(String keyString,String dataString) {
		key[checkNullNum(key)]=keyString;
		data[checkNullNum(data)]=dataString;
	}
	
	//　指定されたキー値に対応したデータを返す関数
	public String get(String keyString) {
		return "1";
	}
	
	//任意の配列にたいして、先頭から数えて初めにnullが格納されている番号を返す関数
	private int checkNullNum(String array[]) {
		int nullNum=0;
		
		//配列の全要素に対して繰り返し
		for(String s:array) {
			if(s==null) {
				break;
			}else {
				nullNum++;
			}
		}
		
		return nullNum;
	}
	
	//checkNullNum関数を外部クラスからテストするための関数1
	public int testCNNForKey() {
		return 	checkNullNum(key);
	}
	
	//checkNullNum関数を外部クラスからテストするための関数2
	public int testCNNForData() {
		return checkNullNum(data);
	}
}
